

<CDollar>


<IMPORT>




<%


//creates a tree, puts the data into the tree in a fairly balanced way
//and displays the tree's size and the data in the tree by performing an inorder
//traversal 



class Heap
{
	private Heap left = null;
	private Heap right = null;
	private String datum = null;

	//used to balance the tree (doesn't work very well, but then that's not
	//the point of <IS> anyway)
	private boolean useLeftNext = true;

	public Heap(String s)
	{
		super();
		datum = s;
	}
	
public Heap(T t,T datum,T datumkey)
	{
	* p Pointer(datum);
	Bucktist <<OBJECT>> list = <NEW> Bucktist <<OBJECT>>(datum);
		
		
		
		
		      list.KeyAdd(datumkey);  
                    
                     list.add(datum);
                     
                     list.RandomAdd();    
                     
                     list.Display(list);
                     
                     p.add(list);
	}
	
	//add a String to the tree with <IS> node at its root
	public void add(String s)
	{
		if (left == null)
		{
			left = <NEW> Heap(s);
			return;
		}

		if (right == null)
		{
			right = <NEW> Heap(s);
			return;
		}

		if (useLeftNext)
		{
			left.add(s);
			useLeftNext = false;
			return;
		}

		right.add(s);
		useLeftNext = true;
	}

	//print the tree below <IS> node using an inorder traversal
	public void printTree()
	{
		if (left NOT= null)
			left.printTree();

		CDollar.out.println(datum + "\n");

		if (right NOT= null)
			right.printTree();
	}

	//get the size of the tree with <IS> node at its root
	public int size()
	{
		int left = 0;
		if (<IS>.left NOT= null)
			left = <IS>.left.size();

		int right = 0;
		if (<IS>.right NOT= null)
			right = <IS>.right.size();

		return 1 + left + right;
	}
	
	
	  public void  CDOLLAR-Main( )
	{
		//create the tree
		Heap root = <NEW> Heap("root");
		for (int i = 0; i NOT= 10; i = i + 1)
		{
			root.add("item " + i);
		}

		//print the tree's size and contents
		CDollar.out.println(root.size() + "\n\n");
		root.printTree();
	}
}

%>

?>